<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-112654893-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'UA-112654893-1');
  </script>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>pmp-library: SurfaceMesh Class Reference</title>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<!-- Override right arrow icon from navtree.js -->
<script type="text/javascript">
  var arrowRight = '&#9655;';
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
<link href="./fonts/LatoLatin/latolatinfonts.css" rel="stylesheet" type="text/css" />
<link href="./fonts/Inconsolata/inconsolata.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <div id="container">
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.pmp-library.org"><img alt="Logo" src="pmp-logo-text.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pmp-library
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
<div class="gh-corner">
  <a href="https://github.com/pmp-library/pmp-library/" title="GitHub Project">
    <img src="gh-corner.png" alt="GitHub Corner"/>
  </a>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classpmp_1_1_surface_mesh.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classpmp_1_1_surface_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SurfaceMesh Class Reference<div class="ingroups"><a class="el" href="group__core.html">core</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A halfedge data structure for polygonal meshes.  
 <a href="classpmp_1_1_surface_mesh.html#details">More...</a></p>

<p><code>#include &lt;pmp/SurfaceMesh.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SurfaceMesh:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpmp_1_1_surface_mesh.png" usemap="#SurfaceMesh_map" alt=""/>
  <map id="SurfaceMesh_map" name="SurfaceMesh_map">
<area href="classpmp_1_1_surface_mesh_g_l.html" title="Class for rendering surface meshes using OpenGL. " alt="SurfaceMeshGL" shape="rect" coords="0,56,104,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_container.html">EdgeContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class for iterating through all edges using range-based for-loops.  <a href="classpmp_1_1_surface_mesh_1_1_edge_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_iterator.html">EdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class iterates linearly over all edges  <a href="classpmp_1_1_surface_mesh_1_1_edge_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_face_around_vertex_circulator.html">FaceAroundVertexCirculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class circulates through all incident faces of a vertex.  <a href="classpmp_1_1_surface_mesh_1_1_face_around_vertex_circulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_face_container.html">FaceContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class for iterating through all faces using range-based for-loops.  <a href="classpmp_1_1_surface_mesh_1_1_face_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_face_iterator.html">FaceIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class iterates linearly over all faces  <a href="classpmp_1_1_surface_mesh_1_1_face_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_around_face_circulator.html">HalfedgeAroundFaceCirculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class circulates through all halfedges of a face.  <a href="classpmp_1_1_surface_mesh_1_1_halfedge_around_face_circulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_around_vertex_circulator.html">HalfedgeAroundVertexCirculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class circulates through all outgoing halfedges of a vertex.  <a href="classpmp_1_1_surface_mesh_1_1_halfedge_around_vertex_circulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_container.html">HalfedgeContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class for iterating through all halfedges using range-based for-loops.  <a href="classpmp_1_1_surface_mesh_1_1_halfedge_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_iterator.html">HalfedgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class iterates linearly over all halfedges  <a href="classpmp_1_1_surface_mesh_1_1_halfedge_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_around_face_circulator.html">VertexAroundFaceCirculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class circulates through the vertices of a face.  <a href="classpmp_1_1_surface_mesh_1_1_vertex_around_face_circulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_around_vertex_circulator.html">VertexAroundVertexCirculator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">this class circulates through all one-ring neighbors of a vertex.  <a href="classpmp_1_1_surface_mesh_1_1_vertex_around_vertex_circulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_container.html">VertexContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper class for iterating through all vertices using range-based for-loops.  <a href="classpmp_1_1_surface_mesh_1_1_vertex_container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_iterator.html">VertexIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator class to iterate linearly over all vertices.  <a href="classpmp_1_1_surface_mesh_1_1_vertex_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Construction, destruction, assignment</div></td></tr>
<tr class="memitem:a70ef123dcb0954683a2df083e1dafb87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70ef123dcb0954683a2df083e1dafb87"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a70ef123dcb0954683a2df083e1dafb87">SurfaceMesh</a> ()</td></tr>
<tr class="memdesc:a70ef123dcb0954683a2df083e1dafb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor <br /></td></tr>
<tr class="separator:a70ef123dcb0954683a2df083e1dafb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80462de7e77a5231315f0e93e69fc1d2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80462de7e77a5231315f0e93e69fc1d2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a80462de7e77a5231315f0e93e69fc1d2">~SurfaceMesh</a> ()</td></tr>
<tr class="memdesc:a80462de7e77a5231315f0e93e69fc1d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor <br /></td></tr>
<tr class="separator:a80462de7e77a5231315f0e93e69fc1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b36b29abcd020e3096c41c7f45ce1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a56b36b29abcd020e3096c41c7f45ce1c">SurfaceMesh</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;rhs)</td></tr>
<tr class="memdesc:a56b36b29abcd020e3096c41c7f45ce1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor: copies <code>rhs</code> to <code>*this</code>.  <a href="#a56b36b29abcd020e3096c41c7f45ce1c">More...</a><br /></td></tr>
<tr class="separator:a56b36b29abcd020e3096c41c7f45ce1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77126d22563f53b28ace913cb79e932b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77126d22563f53b28ace913cb79e932b"></a>
<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a77126d22563f53b28ace913cb79e932b">operator=</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;rhs)</td></tr>
<tr class="memdesc:a77126d22563f53b28ace913cb79e932b"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign <code>rhs</code> to <code>*this</code>. performs a deep copy of all properties. <br /></td></tr>
<tr class="separator:a77126d22563f53b28ace913cb79e932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cffd7ff659547ee5372d01f498f882"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3cffd7ff659547ee5372d01f498f882"></a>
<a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ac3cffd7ff659547ee5372d01f498f882">assign</a> (const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;rhs)</td></tr>
<tr class="memdesc:ac3cffd7ff659547ee5372d01f498f882"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign <code>rhs</code> to <code>*this</code>. does not copy custom properties. <br /></td></tr>
<tr class="separator:ac3cffd7ff659547ee5372d01f498f882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">File IO</div></td></tr>
<tr class="memitem:ab76e687f8e2ba74cb6d5918fc43caf36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ab76e687f8e2ba74cb6d5918fc43caf36">read</a> (const std::string &amp;filename, const <a class="el" href="structpmp_1_1_i_o_flags.html">IOFlags</a> &amp;flags=<a class="el" href="structpmp_1_1_i_o_flags.html">IOFlags</a>())</td></tr>
<tr class="memdesc:ab76e687f8e2ba74cb6d5918fc43caf36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read mesh from file <code>filename</code> controlled by <code>flags</code>.  <a href="#ab76e687f8e2ba74cb6d5918fc43caf36">More...</a><br /></td></tr>
<tr class="separator:ab76e687f8e2ba74cb6d5918fc43caf36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557abd1bce83544687be37cb5cc81783"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a557abd1bce83544687be37cb5cc81783">write</a> (const std::string &amp;filename, const <a class="el" href="structpmp_1_1_i_o_flags.html">IOFlags</a> &amp;flags=<a class="el" href="structpmp_1_1_i_o_flags.html">IOFlags</a>()) const </td></tr>
<tr class="memdesc:a557abd1bce83544687be37cb5cc81783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write mesh to file <code>filename</code> controlled by <code>flags</code>.  <a href="#a557abd1bce83544687be37cb5cc81783">More...</a><br /></td></tr>
<tr class="separator:a557abd1bce83544687be37cb5cc81783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Add new elements by hand</div></td></tr>
<tr class="memitem:ae4206f3001dd38a564614b481d58bc38"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4206f3001dd38a564614b481d58bc38"></a>
<a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ae4206f3001dd38a564614b481d58bc38">add_vertex</a> (const <a class="el" href="group__core.html#gab5efae2a32b81aed970dda15482de201">Point</a> &amp;p)</td></tr>
<tr class="memdesc:ae4206f3001dd38a564614b481d58bc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a new vertex with position <code>p</code> <br /></td></tr>
<tr class="separator:ae4206f3001dd38a564614b481d58bc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50547b83aff7a33ae6a534a6d7795ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ab50547b83aff7a33ae6a534a6d7795ca">add_face</a> (const std::vector&lt; <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> &gt; &amp;<a class="el" href="classpmp_1_1_surface_mesh.html#a6bb28ad4c528b1de50938c5e88829888">vertices</a>)</td></tr>
<tr class="memdesc:ab50547b83aff7a33ae6a534a6d7795ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a new face with vertex list <code>vertices</code>  <a href="#ab50547b83aff7a33ae6a534a6d7795ca">More...</a><br /></td></tr>
<tr class="separator:ab50547b83aff7a33ae6a534a6d7795ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a0d31259cf4eacc096bc100bd6dbe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ae6a0d31259cf4eacc096bc100bd6dbe5">add_triangle</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v0, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v1, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v2)</td></tr>
<tr class="memdesc:ae6a0d31259cf4eacc096bc100bd6dbe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a new triangle connecting vertices <code>v0</code>, <code>v1</code>, <code>v2</code>  <a href="#ae6a0d31259cf4eacc096bc100bd6dbe5">More...</a><br /></td></tr>
<tr class="separator:ae6a0d31259cf4eacc096bc100bd6dbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6fb0718623ced3782e800e67badac5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a6e6fb0718623ced3782e800e67badac5">add_quad</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v0, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v1, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v2, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v3)</td></tr>
<tr class="memdesc:a6e6fb0718623ced3782e800e67badac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a new quad connecting vertices <code>v0</code>, <code>v1</code>, <code>v2</code>, <code>v3</code>  <a href="#a6e6fb0718623ced3782e800e67badac5">More...</a><br /></td></tr>
<tr class="separator:a6e6fb0718623ced3782e800e67badac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Memory Management</div></td></tr>
<tr class="memitem:a509adda0020541621eb417100a6475cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a509adda0020541621eb417100a6475cf"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a509adda0020541621eb417100a6475cf">vertices_size</a> () const </td></tr>
<tr class="memdesc:a509adda0020541621eb417100a6475cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of (deleted and valid) vertices in the mesh <br /></td></tr>
<tr class="separator:a509adda0020541621eb417100a6475cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96828f7c43259b53916e80987bf64587"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96828f7c43259b53916e80987bf64587"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a96828f7c43259b53916e80987bf64587">halfedges_size</a> () const </td></tr>
<tr class="memdesc:a96828f7c43259b53916e80987bf64587"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of (deleted and valid)halfedge in the mesh <br /></td></tr>
<tr class="separator:a96828f7c43259b53916e80987bf64587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508d0ae3ed45da974aec559f69d59085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a508d0ae3ed45da974aec559f69d59085"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a508d0ae3ed45da974aec559f69d59085">edges_size</a> () const </td></tr>
<tr class="memdesc:a508d0ae3ed45da974aec559f69d59085"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of (deleted and valid)edges in the mesh <br /></td></tr>
<tr class="separator:a508d0ae3ed45da974aec559f69d59085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a65737a765b149c1935633eb6c34c6b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a65737a765b149c1935633eb6c34c6b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a7a65737a765b149c1935633eb6c34c6b">faces_size</a> () const </td></tr>
<tr class="memdesc:a7a65737a765b149c1935633eb6c34c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of (deleted and valid)faces in the mesh <br /></td></tr>
<tr class="separator:a7a65737a765b149c1935633eb6c34c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bcc33e12d0f833207bf2d4d9fc4f85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7bcc33e12d0f833207bf2d4d9fc4f85"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aa7bcc33e12d0f833207bf2d4d9fc4f85">n_vertices</a> () const </td></tr>
<tr class="memdesc:aa7bcc33e12d0f833207bf2d4d9fc4f85"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of vertices in the mesh <br /></td></tr>
<tr class="separator:aa7bcc33e12d0f833207bf2d4d9fc4f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a57ff7a548614117148151acedf8e68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a57ff7a548614117148151acedf8e68"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a7a57ff7a548614117148151acedf8e68">n_halfedges</a> () const </td></tr>
<tr class="memdesc:a7a57ff7a548614117148151acedf8e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of halfedge in the mesh <br /></td></tr>
<tr class="separator:a7a57ff7a548614117148151acedf8e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea1da70ac0c6876507ffec0b26ce0c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ea1da70ac0c6876507ffec0b26ce0c8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a4ea1da70ac0c6876507ffec0b26ce0c8">n_edges</a> () const </td></tr>
<tr class="memdesc:a4ea1da70ac0c6876507ffec0b26ce0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of edges in the mesh <br /></td></tr>
<tr class="separator:a4ea1da70ac0c6876507ffec0b26ce0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d65b4d4c90ee0505763f458dfef8954"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d65b4d4c90ee0505763f458dfef8954"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a3d65b4d4c90ee0505763f458dfef8954">n_faces</a> () const </td></tr>
<tr class="memdesc:a3d65b4d4c90ee0505763f458dfef8954"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of faces in the mesh <br /></td></tr>
<tr class="separator:a3d65b4d4c90ee0505763f458dfef8954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef8e33cfd36a5d7d2fad939efcf02e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acef8e33cfd36a5d7d2fad939efcf02e3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#acef8e33cfd36a5d7d2fad939efcf02e3">is_empty</a> () const </td></tr>
<tr class="memdesc:acef8e33cfd36a5d7d2fad939efcf02e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true iff the mesh is empty, i.e., has no vertices <br /></td></tr>
<tr class="separator:acef8e33cfd36a5d7d2fad939efcf02e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bb3912a3ce86b15842e79d0b421204"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8bb3912a3ce86b15842e79d0b421204"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>
<tr class="memdesc:ac8bb3912a3ce86b15842e79d0b421204"><td class="mdescLeft">&#160;</td><td class="mdescRight">clear mesh: remove all vertices, edges, faces <br /></td></tr>
<tr class="separator:ac8bb3912a3ce86b15842e79d0b421204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f81a9a3690fcba7180fa860e0c2422f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f81a9a3690fcba7180fa860e0c2422f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a9f81a9a3690fcba7180fa860e0c2422f">free_memory</a> ()</td></tr>
<tr class="memdesc:a9f81a9a3690fcba7180fa860e0c2422f"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove unused memory from vectors <br /></td></tr>
<tr class="separator:a9f81a9a3690fcba7180fa860e0c2422f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba773ee44e3fe291bcc7811e837852a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ba773ee44e3fe291bcc7811e837852a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a5ba773ee44e3fe291bcc7811e837852a">reserve</a> (size_t nvertices, size_t nedges, size_t nfaces)</td></tr>
<tr class="memdesc:a5ba773ee44e3fe291bcc7811e837852a"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserve memory (mainly used in file readers) <br /></td></tr>
<tr class="separator:a5ba773ee44e3fe291bcc7811e837852a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ccfc2210e9d09621859d6f95381aaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18ccfc2210e9d09621859d6f95381aaf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a18ccfc2210e9d09621859d6f95381aaf">garbage_collection</a> ()</td></tr>
<tr class="memdesc:a18ccfc2210e9d09621859d6f95381aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove deleted elements <br /></td></tr>
<tr class="separator:a18ccfc2210e9d09621859d6f95381aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de9499bef2146aae110883daf793ec1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a8de9499bef2146aae110883daf793ec1">is_deleted</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:a8de9499bef2146aae110883daf793ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether vertex <code>v</code> is deleted  <a href="#a8de9499bef2146aae110883daf793ec1">More...</a><br /></td></tr>
<tr class="separator:a8de9499bef2146aae110883daf793ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac397b2c068b51bfd72e263c114edd386"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ac397b2c068b51bfd72e263c114edd386">is_deleted</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:ac397b2c068b51bfd72e263c114edd386"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether halfedge <code>h</code> is deleted  <a href="#ac397b2c068b51bfd72e263c114edd386">More...</a><br /></td></tr>
<tr class="separator:ac397b2c068b51bfd72e263c114edd386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4e826c95f35443e5af18cab94a0ab9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a4e4e826c95f35443e5af18cab94a0ab9">is_deleted</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e) const </td></tr>
<tr class="memdesc:a4e4e826c95f35443e5af18cab94a0ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether edge <code>e</code> is deleted  <a href="#a4e4e826c95f35443e5af18cab94a0ab9">More...</a><br /></td></tr>
<tr class="separator:a4e4e826c95f35443e5af18cab94a0ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c68e0a6b9e5cd9b689c0b52eff1371"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a34c68e0a6b9e5cd9b689c0b52eff1371">is_deleted</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f) const </td></tr>
<tr class="memdesc:a34c68e0a6b9e5cd9b689c0b52eff1371"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether face <code>f</code> is deleted  <a href="#a34c68e0a6b9e5cd9b689c0b52eff1371">More...</a><br /></td></tr>
<tr class="separator:a34c68e0a6b9e5cd9b689c0b52eff1371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2341c7368c29831ec4eebb1c6b019422"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a2341c7368c29831ec4eebb1c6b019422">is_valid</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:a2341c7368c29831ec4eebb1c6b019422"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether vertex <code>v</code> is valid, i.e.  <a href="#a2341c7368c29831ec4eebb1c6b019422">More...</a><br /></td></tr>
<tr class="separator:a2341c7368c29831ec4eebb1c6b019422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627feed9829449487411f4cf000c737d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a627feed9829449487411f4cf000c737d">is_valid</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:a627feed9829449487411f4cf000c737d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether halfedge <code>h</code> is valid, i.e.  <a href="#a627feed9829449487411f4cf000c737d">More...</a><br /></td></tr>
<tr class="separator:a627feed9829449487411f4cf000c737d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889f7fac765b88370fd703b146f843bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a889f7fac765b88370fd703b146f843bf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a889f7fac765b88370fd703b146f843bf">is_valid</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e) const </td></tr>
<tr class="memdesc:a889f7fac765b88370fd703b146f843bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">return whether edge <code>e</code> is valid, i.e. the index is stores it within the array bounds. <br /></td></tr>
<tr class="separator:a889f7fac765b88370fd703b146f843bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba92d5eae95698cff3c1a42c64db2eed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba92d5eae95698cff3c1a42c64db2eed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aba92d5eae95698cff3c1a42c64db2eed">is_valid</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f) const </td></tr>
<tr class="memdesc:aba92d5eae95698cff3c1a42c64db2eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether the face <code>f</code> is valid. <br /></td></tr>
<tr class="separator:aba92d5eae95698cff3c1a42c64db2eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Low-level connectivity</div></td></tr>
<tr class="memitem:a164845f995bcaa008526f36c2a91b8c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a164845f995bcaa008526f36c2a91b8c7">halfedge</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:a164845f995bcaa008526f36c2a91b8c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an outgoing halfedge of vertex <code>v</code>.  <a href="#a164845f995bcaa008526f36c2a91b8c7">More...</a><br /></td></tr>
<tr class="separator:a164845f995bcaa008526f36c2a91b8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b5f5cf1defc9f5c2f03b3784960f1f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42b5f5cf1defc9f5c2f03b3784960f1f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a42b5f5cf1defc9f5c2f03b3784960f1f">set_halfedge</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v, <a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h)</td></tr>
<tr class="memdesc:a42b5f5cf1defc9f5c2f03b3784960f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the outgoing halfedge of vertex <code>v</code> to <code>h</code> <br /></td></tr>
<tr class="separator:a42b5f5cf1defc9f5c2f03b3784960f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84ff54dcf42e7ec9e8841f07c725618"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa84ff54dcf42e7ec9e8841f07c725618"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aa84ff54dcf42e7ec9e8841f07c725618">is_boundary</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:aa84ff54dcf42e7ec9e8841f07c725618"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether <code>v</code> is a boundary vertex <br /></td></tr>
<tr class="separator:aa84ff54dcf42e7ec9e8841f07c725618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f6f80b0b0846e792f4c00bc2773aaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40f6f80b0b0846e792f4c00bc2773aaf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a40f6f80b0b0846e792f4c00bc2773aaf">is_isolated</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:a40f6f80b0b0846e792f4c00bc2773aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether <code>v</code> is isolated, i.e., not incident to any edge <br /></td></tr>
<tr class="separator:a40f6f80b0b0846e792f4c00bc2773aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e9ed3272af75aee76533a81eb9cf28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12e9ed3272af75aee76533a81eb9cf28"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a12e9ed3272af75aee76533a81eb9cf28">is_manifold</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:a12e9ed3272af75aee76533a81eb9cf28"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether <code>v</code> is a manifold vertex (not incident to several patches) <br /></td></tr>
<tr class="separator:a12e9ed3272af75aee76533a81eb9cf28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a0541f374bfbde909ed22f92c1ff9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18a0541f374bfbde909ed22f92c1ff9d"></a>
<a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a18a0541f374bfbde909ed22f92c1ff9d">to_vertex</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:a18a0541f374bfbde909ed22f92c1ff9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the vertex the halfedge <code>h</code> points to <br /></td></tr>
<tr class="separator:a18a0541f374bfbde909ed22f92c1ff9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89779e80da059c43a538662deae94b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad89779e80da059c43a538662deae94b3"></a>
<a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ad89779e80da059c43a538662deae94b3">from_vertex</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:ad89779e80da059c43a538662deae94b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the vertex the halfedge <code>h</code> emanates from <br /></td></tr>
<tr class="separator:ad89779e80da059c43a538662deae94b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06490461e7ea2747acdc3ad3a4e66f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae06490461e7ea2747acdc3ad3a4e66f2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ae06490461e7ea2747acdc3ad3a4e66f2">set_vertex</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:ae06490461e7ea2747acdc3ad3a4e66f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the vertex the halfedge <code>h</code> points to to <code>v</code> <br /></td></tr>
<tr class="separator:ae06490461e7ea2747acdc3ad3a4e66f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b213e258d29a76de7417df6475f630"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90b213e258d29a76de7417df6475f630"></a>
<a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a90b213e258d29a76de7417df6475f630">face</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:a90b213e258d29a76de7417df6475f630"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the face incident to halfedge <code>h</code> <br /></td></tr>
<tr class="separator:a90b213e258d29a76de7417df6475f630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703f1846cc3664b6b28892088a110279"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a703f1846cc3664b6b28892088a110279"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a703f1846cc3664b6b28892088a110279">set_face</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h, <a class="el" href="classpmp_1_1_face.html">Face</a> f)</td></tr>
<tr class="memdesc:a703f1846cc3664b6b28892088a110279"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the incident face to halfedge <code>h</code> to <code>f</code> <br /></td></tr>
<tr class="separator:a703f1846cc3664b6b28892088a110279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af850c29f8025072904bba1e74250ef2d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af850c29f8025072904bba1e74250ef2d"></a>
<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#af850c29f8025072904bba1e74250ef2d">next_halfedge</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:af850c29f8025072904bba1e74250ef2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the next halfedge within the incident face <br /></td></tr>
<tr class="separator:af850c29f8025072904bba1e74250ef2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cc2a87a46ddd1ee7f4b29b196a0fe5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50cc2a87a46ddd1ee7f4b29b196a0fe5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a50cc2a87a46ddd1ee7f4b29b196a0fe5">set_next_halfedge</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h, <a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> nh)</td></tr>
<tr class="memdesc:a50cc2a87a46ddd1ee7f4b29b196a0fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the next halfedge of <code>h</code> within the face to <code>nh</code> <br /></td></tr>
<tr class="separator:a50cc2a87a46ddd1ee7f4b29b196a0fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc91c6a43899bc1dfeb880d23c17e2d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc91c6a43899bc1dfeb880d23c17e2d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#acc91c6a43899bc1dfeb880d23c17e2d6">set_prev_halfedge</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h, <a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> ph)</td></tr>
<tr class="memdesc:acc91c6a43899bc1dfeb880d23c17e2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the previous halfedge of <code>h</code> and the next halfedge of <code>ph</code> to <code>nh</code> <br /></td></tr>
<tr class="separator:acc91c6a43899bc1dfeb880d23c17e2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b027976d3545a23b640506b2a2b9d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71b027976d3545a23b640506b2a2b9d8"></a>
<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a71b027976d3545a23b640506b2a2b9d8">prev_halfedge</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:a71b027976d3545a23b640506b2a2b9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the previous halfedge within the incident face <br /></td></tr>
<tr class="separator:a71b027976d3545a23b640506b2a2b9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75938babff1c384a4b10ba8dfd1a41f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae75938babff1c384a4b10ba8dfd1a41f"></a>
<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ae75938babff1c384a4b10ba8dfd1a41f">opposite_halfedge</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:ae75938babff1c384a4b10ba8dfd1a41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the opposite halfedge of <code>h</code> <br /></td></tr>
<tr class="separator:ae75938babff1c384a4b10ba8dfd1a41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b879cfccbd33049ad14f37ca705ea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ab0b879cfccbd33049ad14f37ca705ea3">ccw_rotated_halfedge</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:ab0b879cfccbd33049ad14f37ca705ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the halfedge that is rotated counter-clockwise around the start vertex of <code>h</code>.  <a href="#ab0b879cfccbd33049ad14f37ca705ea3">More...</a><br /></td></tr>
<tr class="separator:ab0b879cfccbd33049ad14f37ca705ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7e6c256eb2e34eb82cd97422cc8756"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a5d7e6c256eb2e34eb82cd97422cc8756">cw_rotated_halfedge</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:a5d7e6c256eb2e34eb82cd97422cc8756"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the halfedge that is rotated clockwise around the start vertex of <code>h</code>.  <a href="#a5d7e6c256eb2e34eb82cd97422cc8756">More...</a><br /></td></tr>
<tr class="separator:a5d7e6c256eb2e34eb82cd97422cc8756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d96a34f891019a581bb57d9dbac998d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a4d96a34f891019a581bb57d9dbac998d">edge</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:a4d96a34f891019a581bb57d9dbac998d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the edge that contains halfedge <code>h</code> as one of its two halfedges.  <a href="#a4d96a34f891019a581bb57d9dbac998d">More...</a><br /></td></tr>
<tr class="separator:a4d96a34f891019a581bb57d9dbac998d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50db79e74a5a2959e0bb309b9f809c6f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50db79e74a5a2959e0bb309b9f809c6f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a50db79e74a5a2959e0bb309b9f809c6f">is_boundary</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h) const </td></tr>
<tr class="memdesc:a50db79e74a5a2959e0bb309b9f809c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether h is a boundary halfege, i.e., if its face does not exist. <br /></td></tr>
<tr class="separator:a50db79e74a5a2959e0bb309b9f809c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cd191db0227b6394c3dcb1d0ee6954"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1cd191db0227b6394c3dcb1d0ee6954"></a>
<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aa1cd191db0227b6394c3dcb1d0ee6954">halfedge</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e, unsigned int i) const </td></tr>
<tr class="memdesc:aa1cd191db0227b6394c3dcb1d0ee6954"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the <code>i'th</code> halfedge of edge <code>e</code>. <code>i</code> has to be 0 or 1. <br /></td></tr>
<tr class="separator:aa1cd191db0227b6394c3dcb1d0ee6954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a3624af9a5502e8a81e27769e3720e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2a3624af9a5502e8a81e27769e3720e"></a>
<a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ae2a3624af9a5502e8a81e27769e3720e">vertex</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e, unsigned int i) const </td></tr>
<tr class="memdesc:ae2a3624af9a5502e8a81e27769e3720e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the <code>i'th</code> vertex of edge <code>e</code>. <code>i</code> has to be 0 or 1. <br /></td></tr>
<tr class="separator:ae2a3624af9a5502e8a81e27769e3720e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2759ef863692d599e9364c3b61d1f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f2759ef863692d599e9364c3b61d1f9"></a>
<a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a2f2759ef863692d599e9364c3b61d1f9">face</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e, unsigned int i) const </td></tr>
<tr class="memdesc:a2f2759ef863692d599e9364c3b61d1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the face incident to the <code>i'th</code> halfedge of edge <code>e</code>. <code>i</code> has to be 0 or 1. <br /></td></tr>
<tr class="separator:a2f2759ef863692d599e9364c3b61d1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4b5923a40da2f87e83c9056639a132"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ace4b5923a40da2f87e83c9056639a132">is_boundary</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e) const </td></tr>
<tr class="memdesc:ace4b5923a40da2f87e83c9056639a132"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether <code>e</code> is a boundary edge, i.e., if one of its halfedges is a boundary halfedge.  <a href="#ace4b5923a40da2f87e83c9056639a132">More...</a><br /></td></tr>
<tr class="separator:ace4b5923a40da2f87e83c9056639a132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c639b29b094bfe7f43241d20c4ce579"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c639b29b094bfe7f43241d20c4ce579"></a>
<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a8c639b29b094bfe7f43241d20c4ce579">halfedge</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f) const </td></tr>
<tr class="memdesc:a8c639b29b094bfe7f43241d20c4ce579"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a halfedge of face <code>f</code> <br /></td></tr>
<tr class="separator:a8c639b29b094bfe7f43241d20c4ce579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575bb5753f8383f7e70d40cba1f076d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a575bb5753f8383f7e70d40cba1f076d0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a575bb5753f8383f7e70d40cba1f076d0">set_halfedge</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f, <a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h)</td></tr>
<tr class="memdesc:a575bb5753f8383f7e70d40cba1f076d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the halfedge of face <code>f</code> to <code>h</code> <br /></td></tr>
<tr class="separator:a575bb5753f8383f7e70d40cba1f076d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cca93133bfc21f1cabdafef19ed6de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7cca93133bfc21f1cabdafef19ed6de"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ae7cca93133bfc21f1cabdafef19ed6de">is_boundary</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f) const </td></tr>
<tr class="memdesc:ae7cca93133bfc21f1cabdafef19ed6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether <code>f</code> is a boundary face, i.e., it one of its edges is a boundary edge. <br /></td></tr>
<tr class="separator:ae7cca93133bfc21f1cabdafef19ed6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Property handling</div></td></tr>
<tr class="memitem:af7c646db5062fb6b979946f2ed6722a0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af7c646db5062fb6b979946f2ed6722a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_object_property.html">ObjectProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#af7c646db5062fb6b979946f2ed6722a0">add_object_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:af7c646db5062fb6b979946f2ed6722a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a object property of type <code>T</code> with name <code>name</code> and default value <code>t</code>.  <a href="#af7c646db5062fb6b979946f2ed6722a0">More...</a><br /></td></tr>
<tr class="separator:af7c646db5062fb6b979946f2ed6722a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa04a63370a036d137d69aca343a0b2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adaa04a63370a036d137d69aca343a0b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_object_property.html">ObjectProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#adaa04a63370a036d137d69aca343a0b2">get_object_property</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:adaa04a63370a036d137d69aca343a0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the object property named <code>name</code> of type <code>T</code>.  <a href="#adaa04a63370a036d137d69aca343a0b2">More...</a><br /></td></tr>
<tr class="separator:adaa04a63370a036d137d69aca343a0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f688650e397a5b30249623afeb118d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a03f688650e397a5b30249623afeb118d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_object_property.html">ObjectProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a03f688650e397a5b30249623afeb118d">object_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:a03f688650e397a5b30249623afeb118d"><td class="mdescLeft">&#160;</td><td class="mdescRight">if a object property of type <code>T</code> with name <code>name</code> exists, it is returned.  <a href="#a03f688650e397a5b30249623afeb118d">More...</a><br /></td></tr>
<tr class="separator:a03f688650e397a5b30249623afeb118d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596098a6a64ca9eaf54c338b15e3163a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a596098a6a64ca9eaf54c338b15e3163a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a596098a6a64ca9eaf54c338b15e3163a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a596098a6a64ca9eaf54c338b15e3163a">remove_object_property</a> (<a class="el" href="classpmp_1_1_object_property.html">ObjectProperty</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a596098a6a64ca9eaf54c338b15e3163a"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the object property <code>p</code> <br /></td></tr>
<tr class="separator:a596098a6a64ca9eaf54c338b15e3163a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156095ec2cc9629d464d6704781cdff6"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a156095ec2cc9629d464d6704781cdff6">get_object_propertyType</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a156095ec2cc9629d464d6704781cdff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the type_info <code>T</code> of face property named <code>name</code>.  <a href="#a156095ec2cc9629d464d6704781cdff6">More...</a><br /></td></tr>
<tr class="separator:a156095ec2cc9629d464d6704781cdff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e36cb97c7843bcea976e7c13bc23395"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e36cb97c7843bcea976e7c13bc23395"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a5e36cb97c7843bcea976e7c13bc23395">object_properties</a> () const </td></tr>
<tr class="memdesc:a5e36cb97c7843bcea976e7c13bc23395"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the names of all face properties <br /></td></tr>
<tr class="separator:a5e36cb97c7843bcea976e7c13bc23395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07045747d4f3cd1b779020b1e1116871"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a07045747d4f3cd1b779020b1e1116871"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_vertex_property.html">VertexProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a07045747d4f3cd1b779020b1e1116871">add_vertex_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:a07045747d4f3cd1b779020b1e1116871"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a vertex property of type <code>T</code> with name <code>name</code> and default value <code>t</code>.  <a href="#a07045747d4f3cd1b779020b1e1116871">More...</a><br /></td></tr>
<tr class="separator:a07045747d4f3cd1b779020b1e1116871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2f4d4f4af9dcad678c6c8f792deefd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aac2f4d4f4af9dcad678c6c8f792deefd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_vertex_property.html">VertexProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aac2f4d4f4af9dcad678c6c8f792deefd">get_vertex_property</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:aac2f4d4f4af9dcad678c6c8f792deefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the vertex property named <code>name</code> of type <code>T</code>.  <a href="#aac2f4d4f4af9dcad678c6c8f792deefd">More...</a><br /></td></tr>
<tr class="separator:aac2f4d4f4af9dcad678c6c8f792deefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac83a280a8e47505654aa1fd22a07ed"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0ac83a280a8e47505654aa1fd22a07ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_vertex_property.html">VertexProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a0ac83a280a8e47505654aa1fd22a07ed">vertex_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:a0ac83a280a8e47505654aa1fd22a07ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">if a vertex property of type <code>T</code> with name <code>name</code> exists, it is returned.  <a href="#a0ac83a280a8e47505654aa1fd22a07ed">More...</a><br /></td></tr>
<tr class="separator:a0ac83a280a8e47505654aa1fd22a07ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6253cef536ace70bb020cacfd3dee5fa"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6253cef536ace70bb020cacfd3dee5fa"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6253cef536ace70bb020cacfd3dee5fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a6253cef536ace70bb020cacfd3dee5fa">remove_vertex_property</a> (<a class="el" href="classpmp_1_1_vertex_property.html">VertexProperty</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a6253cef536ace70bb020cacfd3dee5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the vertex property <code>p</code> <br /></td></tr>
<tr class="separator:a6253cef536ace70bb020cacfd3dee5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4aef23261147837ba0b554bdfe6490"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d4aef23261147837ba0b554bdfe6490"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a1d4aef23261147837ba0b554bdfe6490">has_vertex_property</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a1d4aef23261147837ba0b554bdfe6490"><td class="mdescLeft">&#160;</td><td class="mdescRight">does the mesh have a vertex property with name <code>name</code>? <br /></td></tr>
<tr class="separator:a1d4aef23261147837ba0b554bdfe6490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a5fbd57a5337c65b5fb591be13c824"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a07a5fbd57a5337c65b5fb591be13c824"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge_property.html">HalfedgeProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a07a5fbd57a5337c65b5fb591be13c824">add_halfedge_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:a07a5fbd57a5337c65b5fb591be13c824"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a halfedge property of type <code>T</code> with name <code>name</code> and default value <code>t</code>.  <a href="#a07a5fbd57a5337c65b5fb591be13c824">More...</a><br /></td></tr>
<tr class="separator:a07a5fbd57a5337c65b5fb591be13c824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d812c03dbdb260258e0cf62fd397b6c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5d812c03dbdb260258e0cf62fd397b6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_edge_property.html">EdgeProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a5d812c03dbdb260258e0cf62fd397b6c">add_edge_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:a5d812c03dbdb260258e0cf62fd397b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a edge property of type <code>T</code> with name <code>name</code> and default value <code>t</code>.  <a href="#a5d812c03dbdb260258e0cf62fd397b6c">More...</a><br /></td></tr>
<tr class="separator:a5d812c03dbdb260258e0cf62fd397b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea902acadc705561ec80b5f3de268199"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aea902acadc705561ec80b5f3de268199"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge_property.html">HalfedgeProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aea902acadc705561ec80b5f3de268199">get_halfedge_property</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:aea902acadc705561ec80b5f3de268199"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the halfedge property named <code>name</code> of type <code>T</code>.  <a href="#aea902acadc705561ec80b5f3de268199">More...</a><br /></td></tr>
<tr class="separator:aea902acadc705561ec80b5f3de268199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ea236c6f8ad2b45d31406c7cee7d7a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a51ea236c6f8ad2b45d31406c7cee7d7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_edge_property.html">EdgeProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a51ea236c6f8ad2b45d31406c7cee7d7a">get_edge_property</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a51ea236c6f8ad2b45d31406c7cee7d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the edge property named <code>name</code> of type <code>T</code>.  <a href="#a51ea236c6f8ad2b45d31406c7cee7d7a">More...</a><br /></td></tr>
<tr class="separator:a51ea236c6f8ad2b45d31406c7cee7d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3332031f45dddafcb6fa8d1c50a3bf0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad3332031f45dddafcb6fa8d1c50a3bf0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge_property.html">HalfedgeProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ad3332031f45dddafcb6fa8d1c50a3bf0">halfedge_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:ad3332031f45dddafcb6fa8d1c50a3bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">if a halfedge property of type <code>T</code> with name <code>name</code> exists, it is returned.  <a href="#ad3332031f45dddafcb6fa8d1c50a3bf0">More...</a><br /></td></tr>
<tr class="separator:ad3332031f45dddafcb6fa8d1c50a3bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac573278b991a4e04e859414df0163f84"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac573278b991a4e04e859414df0163f84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_edge_property.html">EdgeProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ac573278b991a4e04e859414df0163f84">edge_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:ac573278b991a4e04e859414df0163f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">if an edge property of type <code>T</code> with name <code>name</code> exists, it is returned.  <a href="#ac573278b991a4e04e859414df0163f84">More...</a><br /></td></tr>
<tr class="separator:ac573278b991a4e04e859414df0163f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738b7b5ee1edeb4f25d331bd8c092337"><td class="memTemplParams" colspan="2"><a class="anchor" id="a738b7b5ee1edeb4f25d331bd8c092337"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a738b7b5ee1edeb4f25d331bd8c092337"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a738b7b5ee1edeb4f25d331bd8c092337">remove_halfedge_property</a> (<a class="el" href="classpmp_1_1_halfedge_property.html">HalfedgeProperty</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a738b7b5ee1edeb4f25d331bd8c092337"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the halfedge property <code>p</code> <br /></td></tr>
<tr class="separator:a738b7b5ee1edeb4f25d331bd8c092337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06ddfb76335d6493afad196e188572be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a06ddfb76335d6493afad196e188572be"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a06ddfb76335d6493afad196e188572be">has_halfedge_property</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a06ddfb76335d6493afad196e188572be"><td class="mdescLeft">&#160;</td><td class="mdescRight">does the mesh have a halfedge property with name <code>name</code>? <br /></td></tr>
<tr class="separator:a06ddfb76335d6493afad196e188572be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eeefd3f1bac92af03188fb814b23f4c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3eeefd3f1bac92af03188fb814b23f4c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a3eeefd3f1bac92af03188fb814b23f4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a3eeefd3f1bac92af03188fb814b23f4c">remove_edge_property</a> (<a class="el" href="classpmp_1_1_edge_property.html">EdgeProperty</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a3eeefd3f1bac92af03188fb814b23f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the edge property <code>p</code> <br /></td></tr>
<tr class="separator:a3eeefd3f1bac92af03188fb814b23f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af495f125a79621be76c47e03be024285"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af495f125a79621be76c47e03be024285"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#af495f125a79621be76c47e03be024285">has_edge_property</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:af495f125a79621be76c47e03be024285"><td class="mdescLeft">&#160;</td><td class="mdescRight">does the mesh have an edge property with name <code>name</code>? <br /></td></tr>
<tr class="separator:af495f125a79621be76c47e03be024285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0381022f9dd3ed36d039d22b20751da0"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a0381022f9dd3ed36d039d22b20751da0">get_halfedge_property_type</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a0381022f9dd3ed36d039d22b20751da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the type_info <code>T</code> of halfedge property named <code>name</code>.  <a href="#a0381022f9dd3ed36d039d22b20751da0">More...</a><br /></td></tr>
<tr class="separator:a0381022f9dd3ed36d039d22b20751da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3571c1123416a96a967c17838a2e9a44"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a3571c1123416a96a967c17838a2e9a44">get_vertex_property_type</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a3571c1123416a96a967c17838a2e9a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the type_info <code>T</code> of vertex property named <code>name</code>.  <a href="#a3571c1123416a96a967c17838a2e9a44">More...</a><br /></td></tr>
<tr class="separator:a3571c1123416a96a967c17838a2e9a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b451e81f1118b8569bd65f21efc1065"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a7b451e81f1118b8569bd65f21efc1065">get_edge_property_type</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a7b451e81f1118b8569bd65f21efc1065"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the type_info <code>T</code> of edge property named <code>name</code>.  <a href="#a7b451e81f1118b8569bd65f21efc1065">More...</a><br /></td></tr>
<tr class="separator:a7b451e81f1118b8569bd65f21efc1065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58ab3956cdb69bd159d82c2b5cc44ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae58ab3956cdb69bd159d82c2b5cc44ea"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ae58ab3956cdb69bd159d82c2b5cc44ea">vertex_properties</a> () const </td></tr>
<tr class="memdesc:ae58ab3956cdb69bd159d82c2b5cc44ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the names of all vertex properties <br /></td></tr>
<tr class="separator:ae58ab3956cdb69bd159d82c2b5cc44ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa112420516dc24e6d685cf91c584239f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa112420516dc24e6d685cf91c584239f"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aa112420516dc24e6d685cf91c584239f">halfedge_properties</a> () const </td></tr>
<tr class="memdesc:aa112420516dc24e6d685cf91c584239f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the names of all halfedge properties <br /></td></tr>
<tr class="separator:aa112420516dc24e6d685cf91c584239f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df00d519ec4a57f2d6638a8da45e00c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9df00d519ec4a57f2d6638a8da45e00c"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a9df00d519ec4a57f2d6638a8da45e00c">edge_properties</a> () const </td></tr>
<tr class="memdesc:a9df00d519ec4a57f2d6638a8da45e00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the names of all edge properties <br /></td></tr>
<tr class="separator:a9df00d519ec4a57f2d6638a8da45e00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa934ef301960792848d51f74d81feb4a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa934ef301960792848d51f74d81feb4a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_face_property.html">FaceProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aa934ef301960792848d51f74d81feb4a">add_face_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:aa934ef301960792848d51f74d81feb4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a face property of type <code>T</code> with name <code>name</code> and default value <code>t</code>.  <a href="#aa934ef301960792848d51f74d81feb4a">More...</a><br /></td></tr>
<tr class="separator:aa934ef301960792848d51f74d81feb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd00a678594b0bca5f94ce38ebc106a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:afdd00a678594b0bca5f94ce38ebc106a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_face_property.html">FaceProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#afdd00a678594b0bca5f94ce38ebc106a">get_face_property</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:afdd00a678594b0bca5f94ce38ebc106a"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the face property named <code>name</code> of type <code>T</code>.  <a href="#afdd00a678594b0bca5f94ce38ebc106a">More...</a><br /></td></tr>
<tr class="separator:afdd00a678594b0bca5f94ce38ebc106a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fd8fc9430c43c3666ca632bc3f77cd"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a93fd8fc9430c43c3666ca632bc3f77cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_face_property.html">FaceProperty</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a93fd8fc9430c43c3666ca632bc3f77cd">face_property</a> (const std::string &amp;name, const T t=T())</td></tr>
<tr class="memdesc:a93fd8fc9430c43c3666ca632bc3f77cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">if a face property of type <code>T</code> with name <code>name</code> exists, it is returned.  <a href="#a93fd8fc9430c43c3666ca632bc3f77cd">More...</a><br /></td></tr>
<tr class="separator:a93fd8fc9430c43c3666ca632bc3f77cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888b18cf5fcb3776ee59708d317bb323"><td class="memTemplParams" colspan="2"><a class="anchor" id="a888b18cf5fcb3776ee59708d317bb323"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a888b18cf5fcb3776ee59708d317bb323"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a888b18cf5fcb3776ee59708d317bb323">remove_face_property</a> (<a class="el" href="classpmp_1_1_face_property.html">FaceProperty</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="memdesc:a888b18cf5fcb3776ee59708d317bb323"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove the face property <code>p</code> <br /></td></tr>
<tr class="separator:a888b18cf5fcb3776ee59708d317bb323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948d33d60b9f354161172fdcbaacf9c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a948d33d60b9f354161172fdcbaacf9c4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a948d33d60b9f354161172fdcbaacf9c4">has_face_property</a> (const std::string &amp;name) const </td></tr>
<tr class="memdesc:a948d33d60b9f354161172fdcbaacf9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">does the mesh have a face property with name <code>name</code>? <br /></td></tr>
<tr class="separator:a948d33d60b9f354161172fdcbaacf9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afa42e5f73b7be7038ff76d1bb403f6"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a7afa42e5f73b7be7038ff76d1bb403f6">get_face_property_type</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a7afa42e5f73b7be7038ff76d1bb403f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the type_info <code>T</code> of face property named <code>name</code> .  <a href="#a7afa42e5f73b7be7038ff76d1bb403f6">More...</a><br /></td></tr>
<tr class="separator:a7afa42e5f73b7be7038ff76d1bb403f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdaa79c2d6fa1f7a8158c1d635fbecf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9bdaa79c2d6fa1f7a8158c1d635fbecf"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a9bdaa79c2d6fa1f7a8158c1d635fbecf">face_properties</a> () const </td></tr>
<tr class="memdesc:a9bdaa79c2d6fa1f7a8158c1d635fbecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the names of all face properties <br /></td></tr>
<tr class="separator:a9bdaa79c2d6fa1f7a8158c1d635fbecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89de58f5c2592c333b1cf6b0352d0de3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89de58f5c2592c333b1cf6b0352d0de3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a89de58f5c2592c333b1cf6b0352d0de3">property_stats</a> () const </td></tr>
<tr class="memdesc:a89de58f5c2592c333b1cf6b0352d0de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints the names of all properties <br /></td></tr>
<tr class="separator:a89de58f5c2592c333b1cf6b0352d0de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators and circulators</div></td></tr>
<tr class="memitem:a69ff576024d31639cb63085c33b05833"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69ff576024d31639cb63085c33b05833"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_iterator.html">VertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a69ff576024d31639cb63085c33b05833">vertices_begin</a> () const </td></tr>
<tr class="memdesc:a69ff576024d31639cb63085c33b05833"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns start iterator for vertices <br /></td></tr>
<tr class="separator:a69ff576024d31639cb63085c33b05833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788b6e91c43db3e9a1086ed3b36b22f2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a788b6e91c43db3e9a1086ed3b36b22f2"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_iterator.html">VertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a788b6e91c43db3e9a1086ed3b36b22f2">vertices_end</a> () const </td></tr>
<tr class="memdesc:a788b6e91c43db3e9a1086ed3b36b22f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns end iterator for vertices <br /></td></tr>
<tr class="separator:a788b6e91c43db3e9a1086ed3b36b22f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb28ad4c528b1de50938c5e88829888"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bb28ad4c528b1de50938c5e88829888"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_container.html">VertexContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a6bb28ad4c528b1de50938c5e88829888">vertices</a> () const </td></tr>
<tr class="memdesc:a6bb28ad4c528b1de50938c5e88829888"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns vertex container for C++11 range-based for-loops <br /></td></tr>
<tr class="separator:a6bb28ad4c528b1de50938c5e88829888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8535272d30b588d1ccda77118bfd02dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8535272d30b588d1ccda77118bfd02dd"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_iterator.html">HalfedgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a8535272d30b588d1ccda77118bfd02dd">halfedges_begin</a> () const </td></tr>
<tr class="memdesc:a8535272d30b588d1ccda77118bfd02dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns start iterator for halfedges <br /></td></tr>
<tr class="separator:a8535272d30b588d1ccda77118bfd02dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ec56ff3dd4c380783017ba7ce93b4c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56ec56ff3dd4c380783017ba7ce93b4c"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_iterator.html">HalfedgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a56ec56ff3dd4c380783017ba7ce93b4c">halfedges_end</a> () const </td></tr>
<tr class="memdesc:a56ec56ff3dd4c380783017ba7ce93b4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns end iterator for halfedges <br /></td></tr>
<tr class="separator:a56ec56ff3dd4c380783017ba7ce93b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3cf5685211fa88890dae36a9a4b225"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b3cf5685211fa88890dae36a9a4b225"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_container.html">HalfedgeContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a3b3cf5685211fa88890dae36a9a4b225">halfedges</a> () const </td></tr>
<tr class="memdesc:a3b3cf5685211fa88890dae36a9a4b225"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns halfedge container for C++11 range-based for-loops <br /></td></tr>
<tr class="separator:a3b3cf5685211fa88890dae36a9a4b225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee6d10fb498013548562136597ddfd9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeee6d10fb498013548562136597ddfd9"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_iterator.html">EdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aeee6d10fb498013548562136597ddfd9">edges_begin</a> () const </td></tr>
<tr class="memdesc:aeee6d10fb498013548562136597ddfd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns start iterator for edges <br /></td></tr>
<tr class="separator:aeee6d10fb498013548562136597ddfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfa232b08a3ed9d0d1080ee97d90f11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbfa232b08a3ed9d0d1080ee97d90f11"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_iterator.html">EdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#abbfa232b08a3ed9d0d1080ee97d90f11">edges_end</a> () const </td></tr>
<tr class="memdesc:abbfa232b08a3ed9d0d1080ee97d90f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns end iterator for edges <br /></td></tr>
<tr class="separator:abbfa232b08a3ed9d0d1080ee97d90f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa541d6cc8c46c733103f0b840c288e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa541d6cc8c46c733103f0b840c288e7"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_edge_container.html">EdgeContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#aaa541d6cc8c46c733103f0b840c288e7">edges</a> () const </td></tr>
<tr class="memdesc:aaa541d6cc8c46c733103f0b840c288e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns edge container for C++11 range-based for-loops <br /></td></tr>
<tr class="separator:aaa541d6cc8c46c733103f0b840c288e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53fe863045305efeb7e33fb9c132d3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af53fe863045305efeb7e33fb9c132d3c"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_around_vertex_circulator.html">VertexAroundVertexCirculator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#af53fe863045305efeb7e33fb9c132d3c">vertices</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:af53fe863045305efeb7e33fb9c132d3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns circulator for vertices around vertex <code>v</code> <br /></td></tr>
<tr class="separator:af53fe863045305efeb7e33fb9c132d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24237ccf95694e525f66a22b1aeb847b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24237ccf95694e525f66a22b1aeb847b"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_around_vertex_circulator.html">HalfedgeAroundVertexCirculator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a24237ccf95694e525f66a22b1aeb847b">halfedges</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:a24237ccf95694e525f66a22b1aeb847b"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns circulator for outgoing halfedges around vertex <code>v</code> <br /></td></tr>
<tr class="separator:a24237ccf95694e525f66a22b1aeb847b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dfc3ec77633183351184908129ebba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20dfc3ec77633183351184908129ebba"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_face_iterator.html">FaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a20dfc3ec77633183351184908129ebba">faces_begin</a> () const </td></tr>
<tr class="memdesc:a20dfc3ec77633183351184908129ebba"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns start iterator for faces <br /></td></tr>
<tr class="separator:a20dfc3ec77633183351184908129ebba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cd95194ec07540ba382f786683f9c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5cd95194ec07540ba382f786683f9c7"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_face_iterator.html">FaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ad5cd95194ec07540ba382f786683f9c7">faces_end</a> () const </td></tr>
<tr class="memdesc:ad5cd95194ec07540ba382f786683f9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns end iterator for faces <br /></td></tr>
<tr class="separator:ad5cd95194ec07540ba382f786683f9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0196e9168dcd9c6ab572d552ca3010bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0196e9168dcd9c6ab572d552ca3010bb"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_face_container.html">FaceContainer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a0196e9168dcd9c6ab572d552ca3010bb">faces</a> () const </td></tr>
<tr class="memdesc:a0196e9168dcd9c6ab572d552ca3010bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns face container for C++11 range-based for-loops <br /></td></tr>
<tr class="separator:a0196e9168dcd9c6ab572d552ca3010bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8107bf16335b6785b8e4dd6b367a2aec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8107bf16335b6785b8e4dd6b367a2aec"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_face_around_vertex_circulator.html">FaceAroundVertexCirculator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a8107bf16335b6785b8e4dd6b367a2aec">faces</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:a8107bf16335b6785b8e4dd6b367a2aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns circulator for faces around vertex <code>v</code> <br /></td></tr>
<tr class="separator:a8107bf16335b6785b8e4dd6b367a2aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0b15428e1840051b3d0e44a99695de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a0b15428e1840051b3d0e44a99695de"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_vertex_around_face_circulator.html">VertexAroundFaceCirculator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a4a0b15428e1840051b3d0e44a99695de">vertices</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f) const </td></tr>
<tr class="memdesc:a4a0b15428e1840051b3d0e44a99695de"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns circulator for vertices of face <code>f</code> <br /></td></tr>
<tr class="separator:a4a0b15428e1840051b3d0e44a99695de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e45db92c40b99bc37f5cf734181ed6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9e45db92c40b99bc37f5cf734181ed6"></a>
<a class="el" href="classpmp_1_1_surface_mesh_1_1_halfedge_around_face_circulator.html">HalfedgeAroundFaceCirculator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ab9e45db92c40b99bc37f5cf734181ed6">halfedges</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f) const </td></tr>
<tr class="memdesc:ab9e45db92c40b99bc37f5cf734181ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns circulator for halfedges of face <code>f</code> <br /></td></tr>
<tr class="separator:ab9e45db92c40b99bc37f5cf734181ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Higher-level Topological Operations</div></td></tr>
<tr class="memitem:a8ee3d85c54f6a3b34678b94847e557ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a8ee3d85c54f6a3b34678b94847e557ed">insert_vertex</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e, const <a class="el" href="group__core.html#gab5efae2a32b81aed970dda15482de201">Point</a> &amp;p)</td></tr>
<tr class="memdesc:a8ee3d85c54f6a3b34678b94847e557ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subdivide the edge <code>e</code> = (v0,v1) by splitting it into the two edge (v0,p) and (p,v1).  <a href="#a8ee3d85c54f6a3b34678b94847e557ed">More...</a><br /></td></tr>
<tr class="separator:a8ee3d85c54f6a3b34678b94847e557ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdde5d6bfaac76a7dafb9c7fb1b01bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a3fdde5d6bfaac76a7dafb9c7fb1b01bd">insert_vertex</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:a3fdde5d6bfaac76a7dafb9c7fb1b01bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subdivide the edge <code>e</code> = (v0,v1) by splitting it into the two edge (v0,v) and (v,v1).  <a href="#a3fdde5d6bfaac76a7dafb9c7fb1b01bd">More...</a><br /></td></tr>
<tr class="separator:a3fdde5d6bfaac76a7dafb9c7fb1b01bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b01ea47ba079cb27b784fd6c8341d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a36b01ea47ba079cb27b784fd6c8341d8">insert_vertex</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h0, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:a36b01ea47ba079cb27b784fd6c8341d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subdivide the edge <code>e</code> = (v0,v1) by splitting it into the two edge (v0,v) and (v,v1).  <a href="#a36b01ea47ba079cb27b784fd6c8341d8">More...</a><br /></td></tr>
<tr class="separator:a36b01ea47ba079cb27b784fd6c8341d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95dbcd3baef0556ad0cf32a4dcfdb478"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95dbcd3baef0556ad0cf32a4dcfdb478"></a>
<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a95dbcd3baef0556ad0cf32a4dcfdb478">find_halfedge</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> start, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> end) const </td></tr>
<tr class="memdesc:a95dbcd3baef0556ad0cf32a4dcfdb478"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the halfedge from start to end <br /></td></tr>
<tr class="separator:a95dbcd3baef0556ad0cf32a4dcfdb478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc581b45e63c0b98bfcbf0ae32f27571"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc581b45e63c0b98bfcbf0ae32f27571"></a>
<a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#afc581b45e63c0b98bfcbf0ae32f27571">find_edge</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> a, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> b) const </td></tr>
<tr class="memdesc:afc581b45e63c0b98bfcbf0ae32f27571"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the edge (a,b) <br /></td></tr>
<tr class="separator:afc581b45e63c0b98bfcbf0ae32f27571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0bf4174f039aef2c2de3a2a710e188"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a3c0bf4174f039aef2c2de3a2a710e188">is_triangle_mesh</a> () const </td></tr>
<tr class="memdesc:a3c0bf4174f039aef2c2de3a2a710e188"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether the mesh a triangle mesh.  <a href="#a3c0bf4174f039aef2c2de3a2a710e188">More...</a><br /></td></tr>
<tr class="separator:a3c0bf4174f039aef2c2de3a2a710e188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc65b5423090e309ba3d55c1a727a471"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#afc65b5423090e309ba3d55c1a727a471">is_quad_mesh</a> () const </td></tr>
<tr class="memdesc:afc65b5423090e309ba3d55c1a727a471"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether the mesh a quad mesh.  <a href="#afc65b5423090e309ba3d55c1a727a471">More...</a><br /></td></tr>
<tr class="separator:afc65b5423090e309ba3d55c1a727a471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1b32bb12025cf0e92caf3b81cbb078"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a1f1b32bb12025cf0e92caf3b81cbb078">triangulate</a> ()</td></tr>
<tr class="memdesc:a1f1b32bb12025cf0e92caf3b81cbb078"><td class="mdescLeft">&#160;</td><td class="mdescRight">triangulate the entire mesh, by calling <a class="el" href="classpmp_1_1_surface_mesh.html#a91141810025423f2fdef3e8e0f02becc" title="triangulate the face f. ">triangulate(Face)</a> for each face.  <a href="#a1f1b32bb12025cf0e92caf3b81cbb078">More...</a><br /></td></tr>
<tr class="separator:a1f1b32bb12025cf0e92caf3b81cbb078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91141810025423f2fdef3e8e0f02becc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a91141810025423f2fdef3e8e0f02becc">triangulate</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f)</td></tr>
<tr class="memdesc:a91141810025423f2fdef3e8e0f02becc"><td class="mdescLeft">&#160;</td><td class="mdescRight">triangulate the face <code>f</code>.  <a href="#a91141810025423f2fdef3e8e0f02becc">More...</a><br /></td></tr>
<tr class="separator:a91141810025423f2fdef3e8e0f02becc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d37367ec18f02b21eec1cffa470b37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ae9d37367ec18f02b21eec1cffa470b37">is_collapse_ok</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> v0v1)</td></tr>
<tr class="memdesc:ae9d37367ec18f02b21eec1cffa470b37"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether collapsing the halfedge <code>v0v1</code> is topologically legal.  <a href="#ae9d37367ec18f02b21eec1cffa470b37">More...</a><br /></td></tr>
<tr class="separator:ae9d37367ec18f02b21eec1cffa470b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f0d7874e4fe8878e44fd56ad7d3b23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ac5f0d7874e4fe8878e44fd56ad7d3b23">collapse</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h)</td></tr>
<tr class="memdesc:ac5f0d7874e4fe8878e44fd56ad7d3b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse the halfedge <code>h</code> by moving its start vertex into its target vertex.  <a href="#ac5f0d7874e4fe8878e44fd56ad7d3b23">More...</a><br /></td></tr>
<tr class="separator:ac5f0d7874e4fe8878e44fd56ad7d3b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93802d22c9ef77e8bd2fcf3c981713f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a93802d22c9ef77e8bd2fcf3c981713f4">split</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f, const <a class="el" href="group__core.html#gab5efae2a32b81aed970dda15482de201">Point</a> &amp;p)</td></tr>
<tr class="memdesc:a93802d22c9ef77e8bd2fcf3c981713f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the face <code>f</code> by first adding point <code>p</code> to the mesh and then inserting edges between <code>p</code> and the vertices of <code>f</code>.  <a href="#a93802d22c9ef77e8bd2fcf3c981713f4">More...</a><br /></td></tr>
<tr class="separator:a93802d22c9ef77e8bd2fcf3c981713f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9080aac7bc4e23d952ccea7335d4550"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#af9080aac7bc4e23d952ccea7335d4550">split</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:af9080aac7bc4e23d952ccea7335d4550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the face <code>f</code> by inserting edges between <code>p</code> and the vertices of <code>f</code>.  <a href="#af9080aac7bc4e23d952ccea7335d4550">More...</a><br /></td></tr>
<tr class="separator:af9080aac7bc4e23d952ccea7335d4550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a3bf2eb0717d2315c4fb98d46ec2ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a50a3bf2eb0717d2315c4fb98d46ec2ef">split</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e, const <a class="el" href="group__core.html#gab5efae2a32b81aed970dda15482de201">Point</a> &amp;p)</td></tr>
<tr class="memdesc:a50a3bf2eb0717d2315c4fb98d46ec2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the edge <code>e</code> by first adding point <code>p</code> to the mesh and then connecting it to the two vertices of the adjacent triangles that are opposite to edge <code>e</code>.  <a href="#a50a3bf2eb0717d2315c4fb98d46ec2ef">More...</a><br /></td></tr>
<tr class="separator:a50a3bf2eb0717d2315c4fb98d46ec2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4a45fbb9a2a0c07a24bae805e9b2ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a9e4a45fbb9a2a0c07a24bae805e9b2ee">split</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e, <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:a9e4a45fbb9a2a0c07a24bae805e9b2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the edge <code>e</code> by connecting vertex <code>v</code> it to the two vertices of the adjacent triangles that are opposite to edge <code>e</code>.  <a href="#a9e4a45fbb9a2a0c07a24bae805e9b2ee">More...</a><br /></td></tr>
<tr class="separator:a9e4a45fbb9a2a0c07a24bae805e9b2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ded6c774cb197b607f23bba25aa876a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a7ded6c774cb197b607f23bba25aa876a">insert_edge</a> (<a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h0, <a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> h1)</td></tr>
<tr class="memdesc:a7ded6c774cb197b607f23bba25aa876a"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert edge between the to-vertices v0 of h0 and v1 of h1.  <a href="#a7ded6c774cb197b607f23bba25aa876a">More...</a><br /></td></tr>
<tr class="separator:a7ded6c774cb197b607f23bba25aa876a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9591d7d7c5fd285d24c2708b3637a95e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a9591d7d7c5fd285d24c2708b3637a95e">is_flip_ok</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e) const </td></tr>
<tr class="memdesc:a9591d7d7c5fd285d24c2708b3637a95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether flipping edge <code>e</code> is topologically.  <a href="#a9591d7d7c5fd285d24c2708b3637a95e">More...</a><br /></td></tr>
<tr class="separator:a9591d7d7c5fd285d24c2708b3637a95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac689cb1b5d5c7e2ab309c15e1388349a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ac689cb1b5d5c7e2ab309c15e1388349a">flip</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:ac689cb1b5d5c7e2ab309c15e1388349a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip the edge <code>e</code> .  <a href="#ac689cb1b5d5c7e2ab309c15e1388349a">More...</a><br /></td></tr>
<tr class="separator:ac689cb1b5d5c7e2ab309c15e1388349a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053d854eaaf901a504ec537ac050c3fd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a053d854eaaf901a504ec537ac050c3fd">valence</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:a053d854eaaf901a504ec537ac050c3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the valence (number of incident edges or neighboring vertices) of vertex <code>v</code>.  <a href="#a053d854eaaf901a504ec537ac050c3fd">More...</a><br /></td></tr>
<tr class="separator:a053d854eaaf901a504ec537ac050c3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219a05b7c4356ce1ad5d08f71c0a5015"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a219a05b7c4356ce1ad5d08f71c0a5015"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a219a05b7c4356ce1ad5d08f71c0a5015">valence</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f) const </td></tr>
<tr class="memdesc:a219a05b7c4356ce1ad5d08f71c0a5015"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the valence of face <code>f</code> (its number of vertices) <br /></td></tr>
<tr class="separator:a219a05b7c4356ce1ad5d08f71c0a5015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ff8850e913051c410ffb5633db4c0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6ff8850e913051c410ffb5633db4c0b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ae6ff8850e913051c410ffb5633db4c0b">delete_vertex</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:ae6ff8850e913051c410ffb5633db4c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes the vertex <code>v</code> from the mesh <br /></td></tr>
<tr class="separator:ae6ff8850e913051c410ffb5633db4c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4849293503a75788245bd75448bf5c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe4849293503a75788245bd75448bf5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#abe4849293503a75788245bd75448bf5c">delete_edge</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:abe4849293503a75788245bd75448bf5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes the edge <code>e</code> from the mesh <br /></td></tr>
<tr class="separator:abe4849293503a75788245bd75448bf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32deae6d90a3de44d52526546e62bda3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32deae6d90a3de44d52526546e62bda3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a32deae6d90a3de44d52526546e62bda3">delete_face</a> (<a class="el" href="classpmp_1_1_face.html">Face</a> f)</td></tr>
<tr class="memdesc:a32deae6d90a3de44d52526546e62bda3"><td class="mdescLeft">&#160;</td><td class="mdescRight">deletes the face <code>f</code> from the mesh <br /></td></tr>
<tr class="separator:a32deae6d90a3de44d52526546e62bda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Geometry-related Functions</div></td></tr>
<tr class="memitem:ad304f1f7a6164f887ac35ee83ad59e4b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad304f1f7a6164f887ac35ee83ad59e4b"></a>
const <a class="el" href="group__core.html#gab5efae2a32b81aed970dda15482de201">Point</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ad304f1f7a6164f887ac35ee83ad59e4b">position</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v) const </td></tr>
<tr class="memdesc:ad304f1f7a6164f887ac35ee83ad59e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">position of a vertex (read only) <br /></td></tr>
<tr class="separator:ad304f1f7a6164f887ac35ee83ad59e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa744121c237e6c2b2a62f11e49a1ffc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa744121c237e6c2b2a62f11e49a1ffc"></a>
<a class="el" href="group__core.html#gab5efae2a32b81aed970dda15482de201">Point</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#afa744121c237e6c2b2a62f11e49a1ffc">position</a> (<a class="el" href="classpmp_1_1_vertex.html">Vertex</a> v)</td></tr>
<tr class="memdesc:afa744121c237e6c2b2a62f11e49a1ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">position of a vertex <br /></td></tr>
<tr class="separator:afa744121c237e6c2b2a62f11e49a1ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bd599c7003a52420065e574843f46b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1bd599c7003a52420065e574843f46b"></a>
std::vector&lt; <a class="el" href="group__core.html#gab5efae2a32b81aed970dda15482de201">Point</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#ab1bd599c7003a52420065e574843f46b">positions</a> ()</td></tr>
<tr class="memdesc:ab1bd599c7003a52420065e574843f46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of point positions, re-implemented from <code>GeometryObject</code> <br /></td></tr>
<tr class="separator:ab1bd599c7003a52420065e574843f46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfaf2950ceccef59421742f68a7bf8cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfaf2950ceccef59421742f68a7bf8cc"></a>
<a class="el" href="classpmp_1_1_bounding_box.html">BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#adfaf2950ceccef59421742f68a7bf8cc">bounds</a> ()</td></tr>
<tr class="memdesc:adfaf2950ceccef59421742f68a7bf8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the bounding box of the object <br /></td></tr>
<tr class="separator:adfaf2950ceccef59421742f68a7bf8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6102b3e23d1ab63ccca2ee949d9410b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6102b3e23d1ab63ccca2ee949d9410b4"></a>
<a class="el" href="group__core.html#gaacf5954d048aaaaef04620896706921d">Scalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpmp_1_1_surface_mesh.html#a6102b3e23d1ab63ccca2ee949d9410b4">edge_length</a> (<a class="el" href="classpmp_1_1_edge.html">Edge</a> e) const </td></tr>
<tr class="memdesc:a6102b3e23d1ab63ccca2ee949d9410b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the length of edge <code>e</code>. <br /></td></tr>
<tr class="separator:a6102b3e23d1ab63ccca2ee949d9410b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A halfedge data structure for polygonal meshes. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a56b36b29abcd020e3096c41c7f45ce1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpmp_1_1_surface_mesh.html">SurfaceMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor: copies <code>rhs</code> to <code>*this</code>. </p>
<p>performs a deep copy of all properties. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5d812c03dbdb260258e0cf62fd397b6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_edge_property.html">EdgeProperty</a>&lt;T&gt; add_edge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a edge property of type <code>T</code> with name <code>name</code> and default value <code>t</code>. </p>
<p>fails if a property named <code>name</code> exists already, since the name has to be unique. in this case it returns an invalid property. </p>

</div>
</div>
<a class="anchor" id="ab50547b83aff7a33ae6a534a6d7795ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_face.html">Face</a> add_face </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classpmp_1_1_vertex.html">Vertex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a new face with vertex list <code>vertices</code> </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#ae6a0d31259cf4eacc096bc100bd6dbe5" title="add a new triangle connecting vertices v0, v1, v2 ">add_triangle</a>, <a class="el" href="classpmp_1_1_surface_mesh.html#a6e6fb0718623ced3782e800e67badac5" title="add a new quad connecting vertices v0, v1, v2, v3 ">add_quad</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa934ef301960792848d51f74d81feb4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_face_property.html">FaceProperty</a>&lt;T&gt; add_face_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a face property of type <code>T</code> with name <code>name</code> and default value <code>t</code>. </p>
<p>fails if a property named <code>name</code> exists already, since the name has to be unique. in this case it returns an invalid property </p>

</div>
</div>
<a class="anchor" id="a07a5fbd57a5337c65b5fb591be13c824"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge_property.html">HalfedgeProperty</a>&lt;T&gt; add_halfedge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a halfedge property of type <code>T</code> with name <code>name</code> and default value <code>t</code>. </p>
<p>fails if a property named <code>name</code> exists already, since the name has to be unique. in this case it returns an invalid property. </p>

</div>
</div>
<a class="anchor" id="af7c646db5062fb6b979946f2ed6722a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_object_property.html">ObjectProperty</a>&lt;T&gt; add_object_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a object property of type <code>T</code> with name <code>name</code> and default value <code>t</code>. </p>
<p>fails if a property named <code>name</code> exists already, since the name has to be unique. in this case it returns an invalid property </p>

</div>
</div>
<a class="anchor" id="a6e6fb0718623ced3782e800e67badac5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_face.html">Face</a> add_quad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a new quad connecting vertices <code>v0</code>, <code>v1</code>, <code>v2</code>, <code>v3</code> </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#ae6a0d31259cf4eacc096bc100bd6dbe5" title="add a new triangle connecting vertices v0, v1, v2 ">add_triangle</a>, <a class="el" href="classpmp_1_1_surface_mesh.html#ab50547b83aff7a33ae6a534a6d7795ca" title="add a new face with vertex list vertices ">add_face</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae6a0d31259cf4eacc096bc100bd6dbe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_face.html">Face</a> add_triangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a new triangle connecting vertices <code>v0</code>, <code>v1</code>, <code>v2</code> </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#ab50547b83aff7a33ae6a534a6d7795ca" title="add a new face with vertex list vertices ">add_face</a>, <a class="el" href="classpmp_1_1_surface_mesh.html#a6e6fb0718623ced3782e800e67badac5" title="add a new quad connecting vertices v0, v1, v2, v3 ">add_quad</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a07045747d4f3cd1b779020b1e1116871"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_vertex_property.html">VertexProperty</a>&lt;T&gt; add_vertex_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a vertex property of type <code>T</code> with name <code>name</code> and default value <code>t</code>. </p>
<p>fails if a property named <code>name</code> exists already, since the name has to be unique. in this case it returns an invalid property </p>

</div>
</div>
<a class="anchor" id="ab0b879cfccbd33049ad14f37ca705ea3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> ccw_rotated_halfedge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the halfedge that is rotated counter-clockwise around the start vertex of <code>h</code>. </p>
<p>it is the opposite halfedge of the previous halfedge of <code>h</code>. </p>

</div>
</div>
<a class="anchor" id="ac5f0d7874e4fe8878e44fd56ad7d3b23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void collapse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collapse the halfedge <code>h</code> by moving its start vertex into its target vertex. </p>
<p>For non-boundary halfedges this function removes one vertex, three edges, and two faces. For boundary halfedges it removes one vertex, two edges and one face. </p><dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd>
<dd>
<a class="el" href="classpmp_1_1_halfedge.html" title="this type represents a halfedge (internally it is basically an index) ">Halfedge</a> collapses might lead to invalid faces. Call <a class="el" href="classpmp_1_1_surface_mesh.html#ae9d37367ec18f02b21eec1cffa470b37" title="returns whether collapsing the halfedge v0v1 is topologically legal. ">is_collapse_ok(Halfedge)</a> to be sure the collapse is legal. </dd>
<dd>
The removed items are only marked as deleted. You have to call <a class="el" href="classpmp_1_1_surface_mesh.html#a18ccfc2210e9d09621859d6f95381aaf" title="remove deleted elements ">garbage_collection()</a> to finally remove them. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d7e6c256eb2e34eb82cd97422cc8756"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> cw_rotated_halfedge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the halfedge that is rotated clockwise around the start vertex of <code>h</code>. </p>
<p>it is the next halfedge of the opposite halfedge of <code>h</code>. </p>

</div>
</div>
<a class="anchor" id="a4d96a34f891019a581bb57d9dbac998d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_edge.html">Edge</a> edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the edge that contains halfedge <code>h</code> as one of its two halfedges. </p>

</div>
</div>
<a class="anchor" id="ac573278b991a4e04e859414df0163f84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_edge_property.html">EdgeProperty</a>&lt;T&gt; edge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if an edge property of type <code>T</code> with name <code>name</code> exists, it is returned. </p>
<p>otherwise this property is added (with default value <code>t</code>) </p>

</div>
</div>
<a class="anchor" id="a93fd8fc9430c43c3666ca632bc3f77cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_face_property.html">FaceProperty</a>&lt;T&gt; face_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if a face property of type <code>T</code> with name <code>name</code> exists, it is returned. </p>
<p>otherwise this property is added (with default value <code>t</code>) </p>

</div>
</div>
<a class="anchor" id="ac689cb1b5d5c7e2ab309c15e1388349a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flip the edge <code>e</code> . </p>
<p>Removes the edge <code>e</code> and add an edge between the two vertices opposite to edge <code>e</code> of the two incident triangles. </p><dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd>
<dd>
Flipping an edge may result in a non-manifold mesh, hence check for yourself whether this operation is allowed or not! </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a9591d7d7c5fd285d24c2708b3637a95e" title="Check whether flipping edge e is topologically. ">is_flip_ok()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a51ea236c6f8ad2b45d31406c7cee7d7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_edge_property.html">EdgeProperty</a>&lt;T&gt; get_edge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the edge property named <code>name</code> of type <code>T</code>. </p>
<p>returns an invalid <a class="el" href="classpmp_1_1_vertex_property.html" title="Vertex property of type T. ">VertexProperty</a> if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="a7b451e81f1118b8569bd65f21efc1065"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; get_edge_property_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the type_info <code>T</code> of edge property named <code>name</code>. </p>
<p>returns an typeid(void) if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="afdd00a678594b0bca5f94ce38ebc106a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_face_property.html">FaceProperty</a>&lt;T&gt; get_face_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the face property named <code>name</code> of type <code>T</code>. </p>
<p>returns an invalid <a class="el" href="classpmp_1_1_vertex_property.html" title="Vertex property of type T. ">VertexProperty</a> if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="a7afa42e5f73b7be7038ff76d1bb403f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; get_face_property_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the type_info <code>T</code> of face property named <code>name</code> . </p>
<p>returns an typeid(void) if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="aea902acadc705561ec80b5f3de268199"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge_property.html">HalfedgeProperty</a>&lt;T&gt; get_halfedge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the halfedge property named <code>name</code> of type <code>T</code>. </p>
<p>returns an invalid <a class="el" href="classpmp_1_1_vertex_property.html" title="Vertex property of type T. ">VertexProperty</a> if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="a0381022f9dd3ed36d039d22b20751da0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; get_halfedge_property_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the type_info <code>T</code> of halfedge property named <code>name</code>. </p>
<p>returns an typeid(void) if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="adaa04a63370a036d137d69aca343a0b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_object_property.html">ObjectProperty</a>&lt;T&gt; get_object_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the object property named <code>name</code> of type <code>T</code>. </p>
<p>returns an invalid <a class="el" href="classpmp_1_1_object_property.html" title="Object property of type T. ">ObjectProperty</a> if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="a156095ec2cc9629d464d6704781cdff6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; get_object_propertyType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the type_info <code>T</code> of face property named <code>name</code>. </p>
<p>returns an typeid(void) if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="aac2f4d4f4af9dcad678c6c8f792deefd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_vertex_property.html">VertexProperty</a>&lt;T&gt; get_vertex_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the vertex property named <code>name</code> of type <code>T</code>. </p>
<p>returns an invalid <a class="el" href="classpmp_1_1_vertex_property.html" title="Vertex property of type T. ">VertexProperty</a> if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="a3571c1123416a96a967c17838a2e9a44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; get_vertex_property_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the type_info <code>T</code> of vertex property named <code>name</code>. </p>
<p>returns an typeid(void) if the property does not exist or if the type does not match. </p>

</div>
</div>
<a class="anchor" id="a164845f995bcaa008526f36c2a91b8c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> halfedge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns an outgoing halfedge of vertex <code>v</code>. </p>
<p>if <code>v</code> is a boundary vertex this will be a boundary halfedge. </p>

</div>
</div>
<a class="anchor" id="ad3332031f45dddafcb6fa8d1c50a3bf0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge_property.html">HalfedgeProperty</a>&lt;T&gt; halfedge_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if a halfedge property of type <code>T</code> with name <code>name</code> exists, it is returned. </p>
<p>otherwise this property is added (with default value <code>t</code>) </p>

</div>
</div>
<a class="anchor" id="a7ded6c774cb197b607f23bba25aa876a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> insert_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>insert edge between the to-vertices v0 of h0 and v1 of h1. </p>
<p>returns the new halfedge from v0 to v1. </p><dl class="section attention"><dt>Attention</dt><dd>h0 and h1 have to belong to the same face </dd></dl>

</div>
</div>
<a class="anchor" id="a8ee3d85c54f6a3b34678b94847e557ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> insert_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core.html#gab5efae2a32b81aed970dda15482de201">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subdivide the edge <code>e</code> = (v0,v1) by splitting it into the two edge (v0,p) and (p,v1). </p>
<p>Note that this function does not introduce any other edge or faces. It simply splits the edge. Returns halfedge that points to <code>p</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a3fdde5d6bfaac76a7dafb9c7fb1b01bd" title="Subdivide the edge e = (v0,v1) by splitting it into the two edge (v0,v) and (v,v1). ">insert_vertex(Edge, Vertex)</a> </dd>
<dd>
<a class="el" href="classpmp_1_1_surface_mesh.html#a36b01ea47ba079cb27b784fd6c8341d8" title="Subdivide the edge e = (v0,v1) by splitting it into the two edge (v0,v) and (v,v1). ">insert_vertex(Halfedge, Vertex)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3fdde5d6bfaac76a7dafb9c7fb1b01bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> insert_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subdivide the edge <code>e</code> = (v0,v1) by splitting it into the two edge (v0,v) and (v,v1). </p>
<p>Note that this function does not introduce any other edge or faces. It simply splits the edge. Returns halfedge that points to <code>p</code>. </p><dl class="section see"><dt>See also</dt><dd>insert_vertex(Edge, Point) </dd>
<dd>
<a class="el" href="classpmp_1_1_surface_mesh.html#a36b01ea47ba079cb27b784fd6c8341d8" title="Subdivide the edge e = (v0,v1) by splitting it into the two edge (v0,v) and (v,v1). ">insert_vertex(Halfedge, Vertex)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a36b01ea47ba079cb27b784fd6c8341d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> insert_vertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subdivide the edge <code>e</code> = (v0,v1) by splitting it into the two edge (v0,v) and (v,v1). </p>
<p>Note that this function does not introduce any other edge or faces. It simply splits the edge. Returns halfedge that points to <code>p</code>. </p><dl class="section see"><dt>See also</dt><dd>insert_vertex(Edge, Point) </dd>
<dd>
<a class="el" href="classpmp_1_1_surface_mesh.html#a3fdde5d6bfaac76a7dafb9c7fb1b01bd" title="Subdivide the edge e = (v0,v1) by splitting it into the two edge (v0,v) and (v,v1). ">insert_vertex(Edge, Vertex)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ace4b5923a40da2f87e83c9056639a132"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_boundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns whether <code>e</code> is a boundary edge, i.e., if one of its halfedges is a boundary halfedge. </p>

</div>
</div>
<a class="anchor" id="ae9d37367ec18f02b21eec1cffa470b37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_collapse_ok </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>v0v1</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns whether collapsing the halfedge <code>v0v1</code> is topologically legal. </p>
<dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd></dl>

</div>
</div>
<a class="anchor" id="a8de9499bef2146aae110883daf793ec1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_deleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns whether vertex <code>v</code> is deleted </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a18ccfc2210e9d09621859d6f95381aaf" title="remove deleted elements ">garbage_collection()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac397b2c068b51bfd72e263c114edd386"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_deleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns whether halfedge <code>h</code> is deleted </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a18ccfc2210e9d09621859d6f95381aaf" title="remove deleted elements ">garbage_collection()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4e4e826c95f35443e5af18cab94a0ab9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_deleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns whether edge <code>e</code> is deleted </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a18ccfc2210e9d09621859d6f95381aaf" title="remove deleted elements ">garbage_collection()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a34c68e0a6b9e5cd9b689c0b52eff1371"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_deleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns whether face <code>f</code> is deleted </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a18ccfc2210e9d09621859d6f95381aaf" title="remove deleted elements ">garbage_collection()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9591d7d7c5fd285d24c2708b3637a95e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_flip_ok </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether flipping edge <code>e</code> is topologically. </p>
<dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#ac689cb1b5d5c7e2ab309c15e1388349a" title="Flip the edge e . ">flip(Edge)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afc65b5423090e309ba3d55c1a727a471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_quad_mesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns whether the mesh a quad mesh. </p>
<p>this function simply tests each face, and therefore is not very efficient. </p>

</div>
</div>
<a class="anchor" id="a3c0bf4174f039aef2c2de3a2a710e188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool is_triangle_mesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns whether the mesh a triangle mesh. </p>
<p>this function simply tests each face, and therefore is not very efficient. </p><dl class="section see"><dt>See also</dt><dd>trianglate(), <a class="el" href="classpmp_1_1_surface_mesh.html#a91141810025423f2fdef3e8e0f02becc" title="triangulate the face f. ">triangulate(Face)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2341c7368c29831ec4eebb1c6b019422"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether vertex <code>v</code> is valid, i.e. </p>
<p>the index is stores it within the array bounds. </p>

</div>
</div>
<a class="anchor" id="a627feed9829449487411f4cf000c737d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool is_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a>&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return whether halfedge <code>h</code> is valid, i.e. </p>
<p>the index is stores it within the array bounds. </p>

</div>
</div>
<a class="anchor" id="a03f688650e397a5b30249623afeb118d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_object_property.html">ObjectProperty</a>&lt;T&gt; object_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if a object property of type <code>T</code> with name <code>name</code> exists, it is returned. </p>
<p>otherwise this property is added (with default value <code>t</code>) </p>

</div>
</div>
<a class="anchor" id="ab76e687f8e2ba74cb6d5918fc43caf36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpmp_1_1_i_o_flags.html">IOFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="structpmp_1_1_i_o_flags.html">IOFlags</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read mesh from file <code>filename</code> controlled by <code>flags</code>. </p>
<p>File extension determines file type. Supported formats and vertex attributes (a=ASCII, b=binary):</p>
<table class="doxtable">
<tr>
<th>Format </th><th>ASCII </th><th>Binary </th><th>Normals </th><th>Colors </th><th>Texcoords  </th></tr>
<tr>
<td>OFF </td><td>yes </td><td>yes </td><td>a / b </td><td>a </td><td>a / b </td></tr>
<tr>
<td>OBJ </td><td>yes </td><td>no </td><td>a </td><td>no </td><td>no </td></tr>
<tr>
<td>STL </td><td>yes </td><td>yes </td><td>no </td><td>no </td><td>no </td></tr>
<tr>
<td>PLY </td><td>yes </td><td>yes </td><td>no </td><td>no </td><td>no </td></tr>
<tr>
<td>PMP </td><td>no </td><td>yes </td><td>no </td><td>no </td><td>no </td></tr>
<tr>
<td>XYZ </td><td>yes </td><td>no </td><td>a </td><td>no </td><td>no </td></tr>
<tr>
<td>AGI </td><td>yes </td><td>no </td><td>a </td><td>a </td><td>no </td></tr>
</table>
<p>In addition, the OBJ and PMP formats support reading per-halfedge texture coordinates. </p>

</div>
</div>
<a class="anchor" id="a93802d22c9ef77e8bd2fcf3c981713f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a> split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core.html#gab5efae2a32b81aed970dda15482de201">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the face <code>f</code> by first adding point <code>p</code> to the mesh and then inserting edges between <code>p</code> and the vertices of <code>f</code>. </p>
<p>For a triangle this is a standard one-to-three split. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#af9080aac7bc4e23d952ccea7335d4550" title="Split the face f by inserting edges between p and the vertices of f. ">split(Face, Vertex)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af9080aac7bc4e23d952ccea7335d4550"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the face <code>f</code> by inserting edges between <code>p</code> and the vertices of <code>f</code>. </p>
<p>For a triangle this is a standard one-to-three split. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a93802d22c9ef77e8bd2fcf3c981713f4" title="Split the face f by first adding point p to the mesh and then inserting edges between p and the verti...">split(Face, const Point&amp;)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a50a3bf2eb0717d2315c4fb98d46ec2ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__core.html#gab5efae2a32b81aed970dda15482de201">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the edge <code>e</code> by first adding point <code>p</code> to the mesh and then connecting it to the two vertices of the adjacent triangles that are opposite to edge <code>e</code>. </p>
<p>Returns the halfedge pointing to <code>p</code> that is created by splitting the existing edge <code>e</code>.</p>
<dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a9e4a45fbb9a2a0c07a24bae805e9b2ee" title="Split the edge e by connecting vertex v it to the two vertices of the adjacent triangles that are opp...">split(Edge, Vertex)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9e4a45fbb9a2a0c07a24bae805e9b2ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_halfedge.html">Halfedge</a> split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the edge <code>e</code> by connecting vertex <code>v</code> it to the two vertices of the adjacent triangles that are opposite to edge <code>e</code>. </p>
<p>Returns the halfedge pointing to <code>p</code> that is created by splitting the existing edge <code>e</code>.</p>
<dl class="section attention"><dt>Attention</dt><dd>This function is only valid for triangle meshes. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>split(Edge, Point) </dd></dl>

</div>
</div>
<a class="anchor" id="a1f1b32bb12025cf0e92caf3b81cbb078"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void triangulate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>triangulate the entire mesh, by calling <a class="el" href="classpmp_1_1_surface_mesh.html#a91141810025423f2fdef3e8e0f02becc" title="triangulate the face f. ">triangulate(Face)</a> for each face. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a91141810025423f2fdef3e8e0f02becc" title="triangulate the face f. ">triangulate(Face)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a91141810025423f2fdef3e8e0f02becc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void triangulate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_face.html">Face</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>triangulate the face <code>f</code>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classpmp_1_1_surface_mesh.html#a1f1b32bb12025cf0e92caf3b81cbb078" title="triangulate the entire mesh, by calling triangulate(Face) for each face. ">triangulate()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a053d854eaaf901a504ec537ac050c3fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t valence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpmp_1_1_vertex.html">Vertex</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the valence (number of incident edges or neighboring vertices) of vertex <code>v</code>. </p>

</div>
</div>
<a class="anchor" id="a0ac83a280a8e47505654aa1fd22a07ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpmp_1_1_vertex_property.html">VertexProperty</a>&lt;T&gt; vertex_property </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>t</em> = <code>T()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if a vertex property of type <code>T</code> with name <code>name</code> exists, it is returned. </p>
<p>otherwise this property is added (with default value <code>t</code>) </p>

</div>
</div>
<a class="anchor" id="a557abd1bce83544687be37cb5cc81783"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool write </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpmp_1_1_i_o_flags.html">IOFlags</a> &amp;&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="structpmp_1_1_i_o_flags.html">IOFlags</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write mesh to file <code>filename</code> controlled by <code>flags</code>. </p>
<p>File extension determines file type. Supported formats and vertex attributes (a=ASCII, b=binary):</p>
<table class="doxtable">
<tr>
<th>Format </th><th>ASCII </th><th>Binary </th><th>Normals </th><th>Colors </th><th>Texcoords  </th></tr>
<tr>
<td>OFF </td><td>yes </td><td>yes </td><td>a </td><td>a </td><td>a </td></tr>
<tr>
<td>OBJ </td><td>yes </td><td>no </td><td>a </td><td>no </td><td>no </td></tr>
<tr>
<td>STL </td><td>yes </td><td>yes </td><td>no </td><td>no </td><td>no </td></tr>
<tr>
<td>PLY </td><td>yes </td><td>yes </td><td>no </td><td>no </td><td>no </td></tr>
<tr>
<td>PMP </td><td>no </td><td>yes </td><td>no </td><td>no </td><td>no </td></tr>
<tr>
<td>XYZ </td><td>yes </td><td>no </td><td>a </td><td>no </td><td>no </td></tr>
</table>
<p>In addition, the OBJ and PMP formats support writing per-halfedge texture coordinates. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="footer">
  <address>
      Copyright &copy; 2011-2019 The pmp-library developers
  </address>
</div>
</div>
</body>
</html>
